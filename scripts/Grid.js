// Generated by CoffeeScript 1.6.2
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

define(['Crafty', 'Square'], function(Crafty, Square) {
  var BOUND, COLS, COL_END, DIRSTR, DOWN, END, GRIDLOC, GUTTER, Grid, HORIZ, LEFT, LIMIT, OFFSET, RIGHT, ROWS, ROW_END, SQSIZE, TRUDIR, UP, __DIRSTR__;

  OFFSET = 5;
  GUTTER = 10;
  SQSIZE = 50;
  COLS = 8;
  ROWS = 10;
  UP = 0;
  RIGHT = 1;
  DOWN = 2;
  LEFT = 3;
  LIMIT = 4;
  __DIRSTR__ = ["U", "R", "D", "L"];
  HORIZ = function(dir) {
    return !!(dir % 2);
  };
  TRUDIR = function(dir) {
    var mod;

    mod = dir % LIMIT;
    if (mod < 0) {
      return LIMIT + mod;
    }
    return mod;
  };
  DIRSTR = function(dir) {
    return __DIRSTR__[TRUDIR(dir)];
  };
  BOUND = function(n, min, max) {
    return Math.min(Math.max(n, min), max);
  };
  END = function(dn, n, low, high) {
    if (!dn) {
      return n;
    }
    if (dn > 0) {
      return high;
    }
    return low;
  };
  COL_END = function(dx, x) {
    return END(dx, x, 0, COLS);
  };
  ROW_END = function(dy, y) {
    return END(dy, y, 0, ROWS);
  };
  GRIDLOC = function(n) {
    return n * (SQSIZE + GUTTER) + OFFSET;
  };
  Grid = (function() {
    function Grid() {
      this.removeAndReplace = __bind(this.removeAndReplace, this);
      this.checkConditions = __bind(this.checkConditions, this);
      var col, row, _i, _j, _ref, _ref1;

      this._grid = [];
      for (col = _i = 0, _ref = COLS - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; col = 0 <= _ref ? ++_i : --_i) {
        this._grid[col] = [];
        for (row = _j = 0, _ref1 = ROWS - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; row = 0 <= _ref1 ? ++_j : --_j) {
          this.newSquareAt(col, row, true);
        }
      }
    }

    Grid.prototype.newSquareAt = function(x, y, preventMatching) {
      var e;

      e = Crafty.e(Square).shift(GRIDLOC(x), GRIDLOC(y));
      this.setSquareAt(x, y, e);
      e.randomizeDirection();
      if (preventMatching) {
        while (this.matching(e)) {
          e.randomizeDirection();
        }
      } else {
        e.justInserted();
      }
      e.bind('RotateEnd', this.checkConditions);
      e.bind('InsertEnd', this.checkConditions);
      e.bind('MoveEnd', this.checkConditions);
      return e.bind('ExplodeEnd', this.removeAndReplace);
    };

    Grid.prototype.setSquareAt = function(x, y, e) {
      this._grid[x][y] = e;
      if (e) {
        e.gridX = x;
        return e.gridY = y;
      }
    };

    Grid.prototype.getSquareAt = function(x, y) {
      var _ref;

      return (_ref = this._grid[x]) != null ? _ref[y] : void 0;
    };

    Grid.prototype.matching = function(e) {
      var checkDir, dir, gridX, gridY, matching, toCheck;

      dir = e.getDirection();
      gridX = e.gridX, gridY = e.gridY;
      switch (dir) {
        case UP:
          gridY -= 1;
          break;
        case DOWN:
          gridY += 1;
          break;
        case LEFT:
          gridX -= 1;
          break;
        case RIGHT:
          gridX += 1;
      }
      toCheck = this.getSquareAt(gridX, gridY);
      if (toCheck == null) {
        return;
      }
      if (toCheck.hasExploded()) {
        return;
      }
      checkDir = toCheck.getDirection();
      matching = (function() {
        switch (dir) {
          case UP:
            return checkDir === DOWN;
          case DOWN:
            return checkDir === UP;
          case LEFT:
            return checkDir === RIGHT;
          case RIGHT:
            return checkDir === LEFT;
        }
      })();
      if (matching) {
        return toCheck;
      }
    };

    Grid.prototype.printGridState = function() {
      var col, row, sq, str, _i, _j, _ref, _ref1;

      for (row = _i = 0, _ref = ROWS - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; row = 0 <= _ref ? ++_i : --_i) {
        str = '';
        for (col = _j = 0, _ref1 = COLS - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; col = 0 <= _ref1 ? ++_j : --_j) {
          sq = this.getSquareAt(col, row);
          if (sq != null) {
            if (sq.hasExploded()) {
              str += "*";
            } else {
              str += DIRSTR(sq.getDirection());
            }
          } else {
            str += "_";
          }
        }
        console.log(str);
      }
      return console.log(' ');
    };

    Grid.prototype.nullOut = function(e) {
      return this.setSquareAt(e.gridX, e.gridY, null);
    };

    Grid.prototype.detonate = function(e) {
      return e.explode();
    };

    Grid.prototype.checkConditions = function(e) {
      var toCheck;

      if (e.hasExploded()) {
        return;
      }
      toCheck = this.matching(e);
      if (toCheck != null) {
        this.detonate(e);
        return this.detonate(toCheck);
      }
    };

    Grid.prototype.removeAndReplace = function(e) {
      var gridX, gridY;

      gridX = e.gridX, gridY = e.gridY;
      this.nullOut(e);
      e.destroy();
      switch (e.getDirection()) {
        case UP:
          this.shiftStartingAt(gridX, gridY, 0, -1);
          break;
        case DOWN:
          this.shiftStartingAt(gridX, gridY, 0, 1);
          break;
        case LEFT:
          this.shiftStartingAt(gridX, gridY, -1, 0);
          break;
        case RIGHT:
          this.shiftStartingAt(gridX, gridY, 1, 0);
      }
    };

    Grid.prototype.runForGrid = function(callback) {
      var col, row, _i, _j, _ref, _ref1;

      for (col = _i = 0, _ref = COLS - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; col = 0 <= _ref ? ++_i : --_i) {
        for (row = _j = 0, _ref1 = ROWS - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; row = 0 <= _ref1 ? ++_j : --_j) {
          callback(col, row);
        }
      }
    };

    Grid.prototype.auditGrid = function() {
      var _this = this;

      return this.runForGrid(function(col, row) {
        var e;

        e = _this.getSquareAt(col, row);
        if (!e) {
          return;
        }
        if (GRIDLOC(e.gridX) !== e.x) {
          return console.log('X Failed for');
        }
      });
    };

    Grid.prototype.ensureGrid = function() {
      var _this = this;

      return this.runForGrid(function(col, row) {
        if (!_this.getSquareAt(col, row)) {
          return _this.newSquareAt(col, row, false);
        }
      });
    };

    Grid.prototype.shiftStartingAt = function(x, y, dx, dy) {
      var col, endX, endY, row, sq, startX, startY, _i, _j;

      startX = x - dx;
      endX = END(-dx, startX, 0, COLS - 1);
      startY = y - dy;
      endY = END(-dy, startY, 0, ROWS - 1);
      for (col = _i = startX; startX <= endX ? _i <= endX : _i >= endX; col = startX <= endX ? ++_i : --_i) {
        for (row = _j = startY; startY <= endY ? _j <= endY : _j >= endY; row = startY <= endY ? ++_j : --_j) {
          sq = this.getSquareAt(col, row);
          if (sq != null) {
            this.moveWithinGrid(sq, dx, dy);
          }
        }
      }
      this.ensureGrid();
    };

    Grid.prototype.moveWithinGrid = function(e, dx, dy) {
      var newX, newY;

      if (!((e != null) && !e.hasExploded())) {
        return;
      }
      newX = e.gridX + dx;
      newY = e.gridY + dy;
      if (!this.getSquareAt(newX, newY)) {
        this.nullOut(e);
        this.setSquareAt(newX, newY, e);
        return e.moveTo(GRIDLOC(newX), GRIDLOC(newY));
      }
    };

    return Grid;

  })();
  return Grid;
});
